/************************************************************************************************************
 *                                                                                                          *
 *                                ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo         *
 *                             o                                                                            *
 *                          o                                                                               *
 *                        o                                                                                 *
 *                      o                                                                                   *
 *                     o       ooooooo       ooooooo    o         o      oo                                 *
 *    o              o       o        o     o       o   o         o     o   o                               *
 *      o           o       o          o   o         o  o         o    o      o                             *
 *        o        o       o           o   o         o  o         o    o        o                           *
 *         o      o        o      oooo     o         o  o         o   o           o                         *
 *          o    o          o              o         o  o         o   o           o                         *
 *           o  o            o             o         o  o o      o   o          o                           *
 *            oo              oooooooo    o         o   o  oooooo   o      oooo                             *
 *                                                     o                                                    *
 *                                                     o                                                    *
 *                                                    o                            o                        *
 *                                                    o            o      oooo     o   o      oooo          *
 *                                                   o             o         o    o    o         o          *
 *                                                   o            o       ooo     o   o       ooo           *
 *                                                               o       o       o   o          o           *
 *                                                               ooooo   oooo    o   ooooo  oooo            *
 *                                                                              o                           *
 *                                                                                                          *
 ************************************************************************************************************
 *                                                                                                          *
 * Author: CS Systemes d'Information  (France)                                                              *
 *                                                                                                          *
 ************************************************************************************************************
 * HISTORIQUE                                                                                               *
 *                                                                                                          *
 * VERSION : 2.1.0 : FA : LAIG-FA-MAJA-2346-CNES : 06 juillet 2017 : Correction suite division par  0       *
 * VERSION : 2.0.0 : FA : LAIG-FA-MAJA-2168-CNES : 28 fevrier 2017 : Correction I3D car sortie en erreur    *
 *                                                                                         boite englobante *
 * VERSION : 1.0.0 : FA : LAIG-FA-MAC-1988-CNES : 20 decembre 2016 : Correction qualite (code mort)         *
 * VERSION : 5-1-0 : FA : LAIG-FA-MAC-144719-CS : 17 mai 2016 : Correction warning et contrôle qualité      *
 * VERSION : 4-4-1 : FA : LAIG-FA-MAC-127944-CS : 9 juillet 2015 : Correction warning et contrôle qualité   *
 * 														sur le code source C++   							*
 * VERSION : 4-4-0 : FA : LAIG-FA-MAC-127944-CS : 3 juin 2015 : Correction code pour la qualite             *
 * VERSION : 4-0-0 : FA : LAIG-FA-MAC-117040-CS : 13 mars 2014 : Modifications mineures                     *
 * VERSION : 3-0-0 : DM : LAIG-DM-MAC-239-CNES : 10 mai 2013 : Prise en compte de la DM incluant notamment   *
 *                                                            le MACCS generique (PM LAIG-NT-MAC-0239-CNES) *
 * VERSION : 1-0-0 : <TypeFT> : <NumFT> : 25 mai 2010 : Creation
 *                                                                                                          *
 * FIN-HISTORIQUE                                                                                           *
 *                                                                                                          *
 * $Id$
 *                                                                                                          *
 ************************************************************************************************************/
#include "MntIntersecteur.h"

#include <sstream>
#include <cstdio>
#include "string.h"
#include "stdlib.h"

#include "math.h"

#define TOL_Z .0001
#define TOL_D .000000000001

#define BUFF_SIZE 1024

#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <iomanip>
#include <iostream>

namespace Intersecteur
{
    ////////////////////////////////////////////////////////////////////////////////////////////////
    // fmygets
    ////////////////////////////////////////////////////////////////////////////////////////////////
    void
    fmygets(char * str, int n, FILE * file)
    {
        // -----------------------------------------------------------------------
        str[0] = 0;

        // -----------------------------------------------------------------------
        if (feof(file))
            return;
        // -----------------------------------------------------------------------
        int i = 0;
        long pos = -1;
        // -----------------------------------------------------------------------
        while (i < n && !feof(file))
        {
            // -----------------------------------------------------------------------
            char c;
            // -----------------------------------------------------------------------
            int len = fread(&c, sizeof(char), 1, file);
            // -----------------------------------------------------------------------
            if (len > 0)
            {
                // -----------------------------------------------------------------------
                if (c == '\n')
                {
                    // -----------------------------------------------------------------------
                    str[i] = 0;
                    pos = ftell(file);
                    break;
                }
                // -----------------------------------------------------------------------
                if (c == '\r')
                {
                    // -----------------------------------------------------------------------
                    str[i] = 0;
                    // -----------------------------------------------------------------------
                    pos = ftell(file);
                    break;
                }
                // -----------------------------------------------------------------------
                str[i] = c;
            }
            // -----------------------------------------------------------------------
            else
            {
                // -----------------------------------------------------------------------
                str[i] = 0;
                return;
            }
            // -----------------------------------------------------------------------
            i++;
        }
        // -----------------------------------------------------------------------
        bool newline = false;
        // -----------------------------------------------------------------------
        while (i < n && !feof(file) && !newline)
        {
            // -----------------------------------------------------------------------
            char c;
            // -----------------------------------------------------------------------
            int len = fread(&c, sizeof(char), 1, file);
            // -----------------------------------------------------------------------
            if (len > 0)
            {
                // -----------------------------------------------------------------------
                newline = true;
                // -----------------------------------------------------------------------
                if (c == '\n')
                {
                    pos = ftell(file);
                    newline = false;
                }
                // -----------------------------------------------------------------------
                if (c == '\r')
                {
                    pos = ftell(file);
                    newline = false;
                }
            }
            // -----------------------------------------------------------------------
            else
            {
                return;
            }
        }
        // -----------------------------------------------------------------------
        if (pos != -1)
            // -----------------------------------------------------------------------
            fseek(file, pos, SEEK_SET);
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////
    // fmyread
    ////////////////////////////////////////////////////////////////////////////////////////////////
    bool
    fmyread(const std::string & key, std::string & val, FILE * file)
    {
        // -----------------------------------------------------------------------
        std::string readkey;
        // -----------------------------------------------------------------------
        val = "";

        // -----------------------------------------------------------------------
        bool bRetry = true;

        // -----------------------------------------------------------------------
        while (bRetry)
        {
            // -----------------------------------------------------------------------
            bRetry = false;
            // -----------------------------------------------------------------------
            char buf[BUFF_SIZE];
            fmygets(buf, BUFF_SIZE, file);
            // -----------------------------------------------------------------------
            while (buf[0] == '/')
                fmygets(buf, BUFF_SIZE, file);
            // -----------------------------------------------------------------------
            if (strlen(buf) > 2)
            {
                // -----------------------------------------------------------------------
                if (buf[0] == '>' && buf[1] == '>' && buf[2] == '\t')
                {
                    // -----------------------------------------------------------------------
                    unsigned int i;
                    // -----------------------------------------------------------------------
                    for (i = 3; i < strlen(buf) && buf[i] != '\t'; ++i)
                    {
                        readkey += buf[i];
                    }
                    // -----------------------------------------------------------------------
                    if (readkey == key)
                    {
                        ++i;
                        // -----------------------------------------------------------------------
                        while (i < strlen(buf) && buf[i] != '\t')
                        {
                            // -----------------------------------------------------------------------
                            val += buf[i];
                            ++i;
                        }
                        // -----------------------------------------------------------------------
                        return true;
                    }
                    // -----------------------------------------------------------------------
                    else
                    {
                        // -----------------------------------------------------------------------
                        bRetry = true;
                    }
                }
            }
        }
        // -----------------------------------------------------------------------
        return false;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////
    // FromString
    ////////////////////////////////////////////////////////////////////////////////////////////////
    template<class T>
        T
        FromString(const std::string & chaine)
        {
            T res;
            std::istringstream tmp(chaine);
            tmp >> res;
            return res;
        }

    ////////////////////////////////////////////////////////////////////////////////////////////////
    // Constructeurs, Destructeurs
    ////////////////////////////////////////////////////////////////////////////////////////////////
    MntIntersecteur::MntIntersecteur()
    {
        // -----------------------------------------------------------------------
        _bIsLoaded = false;

        // -----------------------------------------------------------------------
        _nc = 0;
        _nl = 0;

        // -----------------------------------------------------------------------
        _px = 0;
        _py = 0;

        // -----------------------------------------------------------------------
        _x0 = 0;
        _y0 = 0;

        // -----------------------------------------------------------------------
        _i1 = 0;
        _i2 = 0;

        // -----------------------------------------------------------------------
        _d1 = 0;
        _d2 = 0;

        // -----------------------------------------------------------------------
        _pZ = NULL;

        // -----------------------------------------------------------------------
        _freepZ = true;

        // -----------------------------------------------------------------------
        _zMin = 0;
        _zMax = 0;

        // -----------------------------------------------------------------------
        _pZMin = NULL;
        _pZMax = NULL;
    }

    MntIntersecteur::~MntIntersecteur()
    {
        // -----------------------------------------------------------------------
        if (_pZ && (_freepZ == true))
            free(_pZ);
        // -----------------------------------------------------------------------
        if (_pZMin)
            free(_pZMin);
        // -----------------------------------------------------------------------
        if (_pZMax)
            free(_pZMax);
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////
    // Charger
    ////////////////////////////////////////////////////////////////////////////////////////////////
    bool
    MntIntersecteur::Charger(const std::string & Name)
    {
        // -----------------------------------------------------------------------
        // Lecture de tout le MNT
        if (Name.empty())
        {
            SetError("MntIntersecteur::Charger()", "Pas de nom de fichier.");
            return false;
        }

        // -----------------------------------------------------------------------
        std::string FileNameHD = Name + ".hd_babel";

        // -----------------------------------------------------------------------
        FILE * f = fopen(FileNameHD.c_str(), "rb");
        // -----------------------------------------------------------------------
        if (!f)
        {
            // -----------------------------------------------------------------------
            SetError("MntIntersecteur::Charger()", "Echec d'ouverture fichier " + FileNameHD + ".");
            return false;
        }

        // -----------------------------------------------------------------------
        // Lecture des attributs du MNT (contenus dans le fichier hd_babel)
        std::string Temp;
        // -----------------------------------------------------------------------
        bool bErrorReadingHeader = false;

        // -----------------------------------------------------------------------
        if (!fmyread("LON_REF", Temp, f))
            bErrorReadingHeader = true;
        // -----------------------------------------------------------------------
        _x0 = FromString<double>(Temp);

        // -----------------------------------------------------------------------
        if (!fmyread("LAT_REF", Temp, f))
            bErrorReadingHeader = true;
        // -----------------------------------------------------------------------
        _y0 = FromString<double>(Temp);

        // -----------------------------------------------------------------------
        if (!fmyread("NB_LON", Temp, f))
            bErrorReadingHeader = true;
        // -----------------------------------------------------------------------
        _nc = FromString<int>(Temp);

        // -----------------------------------------------------------------------
        if (!fmyread("NB_LAT", Temp, f))
            bErrorReadingHeader = true;
        // -----------------------------------------------------------------------
        _nl = FromString<int>(Temp);

        // -----------------------------------------------------------------------
        if (!fmyread("PAS_LON", Temp, f))
            bErrorReadingHeader = true;
        // -----------------------------------------------------------------------
        _px = FromString<double>(Temp);

        // -----------------------------------------------------------------------
        if (!fmyread("PAS_LAT", Temp, f))
            bErrorReadingHeader = true;
        // -----------------------------------------------------------------------
        _py = FromString<double>(Temp);

        // -----------------------------------------------------------------------
        if (!fmyread("TYPE_CODE", Temp, f))
            bErrorReadingHeader = true;
        // -----------------------------------------------------------------------
        int nTypeCode = FromString<int>(Temp);

        // -----------------------------------------------------------------------
        if (!fmyread("TYPE_CONV", Temp, f))
            bErrorReadingHeader = true;
        // -----------------------------------------------------------------------
        int nTypeConv = FromString<int>(Temp);

        // -----------------------------------------------------------------------
        switch (nTypeConv)
            {
        // -----------------------------------------------------------------------
        case eTCNone:
            /*
             _typeConv = eTCNone;
             */
            break;
            // -----------------------------------------------------------------------
        case eTCRelative:
            /*
             _typeConv = eTCRelative;
             if ( !fmyread("H_REF", Temp) ) bErrorReadingHeader = true;
             _specConv._relat._altitudeRef = FromString<double>(Temp);
             if ( !fmyread("S_H", Temp) ) bErrorReadingHeader = true;
             _specConv._relat._scale = FromString<double>(Temp);
             */
            {
                // -----------------------------------------------------------------------
                fclose(f);
                SetError("MntIntersecteur::Charger()", "Seul le TypeConv 'None' est g?r?.");
                return false;
            }
            break;
            // -----------------------------------------------------------------------
        case eTCIntervale:
            /*
             _typeConv = eTCIntervale;
             if ( !fmyread("H_MIN", Temp) ) bErrorReadingHeader = true;
             _specConv._inter._altitudeMin = FromString<double>(Temp);
             if ( !fmyread("H_MAX", Temp) ) bErrorReadingHeader = true;
             _specConv._inter._altitudeMax = FromString<double>(Temp);
             */
            {
                // -----------------------------------------------------------------------
                fclose(f);
                SetError("MntIntersecteur::Charger()", "Seul le TypeConv 'None' est g?r?.");
                return false;
            }
            // -----------------------------------------------------------------------
            break;
            // -----------------------------------------------------------------------
        default:
            break;
            }

        // -----------------------------------------------------------------------
        if (!fmyread("REF", _Ident, f))
            bErrorReadingHeader = true;

        // -----------------------------------------------------------------------
        fclose(f);

        // -----------------------------------------------------------------------
        if (bErrorReadingHeader)
        {
            SetError("MntIntersecteur::Charger()", "Erreur lors de la lecture du header.");
            return false;
        }

        // -----------------------------------------------------------------------
        // Respect de l'existant SP5LIB...
        if (_Ident == "GRS80_GEO")
        {
            _Ident = "GRS80:G-D/GRS80:Z-M";
        }

        // -----------------------------------------------------------------------
        _d1 = _px;
        _d2 = _py;

        // -----------------------------------------------------------------------
        _i1 = 1.0 / _py;
        _i2 = 1.0 / _px;

        // -----------------------------------------------------------------------
        // Contr?les
        if (_nc < 2 || _nl < 2)
        {
            // -----------------------------------------------------------------------
            SetError("MntIntersecteur::Charger()", "Dimensions de grille incorrectes.");
            return false;
        }

        // -----------------------------------------------------------------------
        // Lecture des attributs du MNT (contenus dans le fichier hd)
        int nNbCan = 0;
        int nNbOctPix = 0;
        // -----------------------------------------------------------------------
        int nNbCol = 0;
        int nNbLig = 0;

        // -----------------------------------------------------------------------
        char pFilename[2048];
        strcpy(pFilename, Name.c_str());

        // -----------------------------------------------------------------------
        char pFilenameHD[2048];
        // -----------------------------------------------------------------------
        strcpy(pFilenameHD, pFilename);
        // -----------------------------------------------------------------------
        strcat(pFilenameHD, ".hd");
        f = fopen(pFilenameHD, "rb");
        // -----------------------------------------------------------------------
        if (!f)
        {
            SetError("MntIntersecteur::Charger()", "Echec ouverture image " + std::string(pFilenameHD));
            return false;
        }

        // -----------------------------------------------------------------------
        bool bNbCanFound = false;
        bool bNbOctPixFound = false;
        // -----------------------------------------------------------------------
        bool bNbColFound = false;
        bool bNbLigFound = false;

        // -----------------------------------------------------------------------
        while (!feof(f))
        // -----------------------------------------------------------------------
        {
            char buf[512];
            // -----------------------------------------------------------------------
            fmygets(buf, 512, f);
            // -----------------------------------------------------------------------
            if (strcmp(buf, "CHANNELS") == 0)
            {
                // -----------------------------------------------------------------------
                fmygets(buf, 512, f);
                nNbCan = atoi(buf);
                bNbCanFound = true;
            }
            // -----------------------------------------------------------------------
            if (strcmp(buf, "LINES") == 0)
            {
                fmygets(buf, 512, f);
                nNbLig = atoi(buf);
                bNbLigFound = true;
            }
            // -----------------------------------------------------------------------
            if (strcmp(buf, "COLUMNS") == 0)
            {
                fmygets(buf, 512, f);
                nNbCol = atoi(buf);
                bNbColFound = true;
            }
            // -----------------------------------------------------------------------
            if (strcmp(buf, "BITS PER PIXEL") == 0)
            {
                fmygets(buf, 512, f);
                nNbOctPix = atoi(buf) / 8;
                bNbOctPixFound = true;
            }
        }
        // -----------------------------------------------------------------------
        fclose(f);
        // -----------------------------------------------------------------------
        if (!bNbCanFound || !bNbOctPixFound || !bNbColFound || !bNbLigFound)
        {
            // -----------------------------------------------------------------------
            SetError("MntIntersecteur::Charger()", "Echec lecture header.");
            return false;
        }
        // -----------------------------------------------------------------------
        strcat(pFilename, ".c1");
        // -----------------------------------------------------------------------
        f = fopen(pFilename, "rb");
        // -----------------------------------------------------------------------
        if (f == NULL)
        // -----------------------------------------------------------------------
        {
            SetError("MntIntersecteur::Charger()", "Echec ouverture image du fichier " + std::string(pFilename));
            return false;
        }

        // -----------------------------------------------------------------------
        // Controle des donnees de l'image
        if (nNbCan != 1)
        {
            // -----------------------------------------------------------------------
            fclose(f);
            SetError("MntIntersecteur::Charger()", "Nombre de canaux incorrect.");
            return false;
        }
        // -----------------------------------------------------------------------
        if ((nNbCol != _nc) || (nNbLig != _nl))
        {
            fclose(f);
            // -----------------------------------------------------------------------
            SetError("MntIntersecteur::Charger()", "Incoherence sur les dimensions.");
            return false;
        }
        // -----------------------------------------------------------------------
        if (((nTypeCode == eTVChar) && (nNbOctPix != sizeof(char))) || ((nTypeCode == eTVUChar) && (nNbOctPix != sizeof(unsigned char)))
                || ((nTypeCode == eTVShort) && (nNbOctPix != sizeof(short)))
                || ((nTypeCode == eTVUShort) && (nNbOctPix != sizeof(unsigned short)))
                || ((nTypeCode == eTVInt) && (nNbOctPix != sizeof(int))) || ((nTypeCode == eTVUInt) && (nNbOctPix != sizeof(unsigned int)))
                || ((nTypeCode == eTVFloat) && (nNbOctPix != sizeof(float))) || ((nTypeCode == eTVDouble) && (nNbOctPix != sizeof(double))))
        {
            // -----------------------------------------------------------------------
            fclose(f);
            SetError("MntIntersecteur::Charger()", "Incoherence entre BITS PER PIXEL et TYPE_CODE.");
            return false;
        }

        // -----------------------------------------------------------------------
        // allocation du buffer destination (buffer de doubles)
        if (_pZ && (_freepZ == true))
            free(_pZ);
        // -----------------------------------------------------------------------
        _pZ = (double*) malloc(_nc * _nl * sizeof(double));
        // -----------------------------------------------------------------------
        _freepZ = true;

        // -----------------------------------------------------------------------
        int nLig;
        int nCol;
        // -----------------------------------------------------------------------
        double * pZ;

        // suivant types de donn?es
        // -----------------------------------------------------------------------
        switch (nTypeCode)
            {
        //---------- char -------
        case eTVChar:
            _TypeVal = eTVChar;

            // allocation du buffer tampon
            // -----------------------------------------------------------------------
            char * pc_buf;
            char * pc_buf_tmp;
            // -----------------------------------------------------------------------
            pc_buf = (char *) malloc(_nc * _nl * sizeof(char));
            pc_buf_tmp = pc_buf;

            // -----------------------------------------------------------------------
            // Lecture d'un canal
            for (nLig = 0; nLig < nNbLig; nLig++)
            {
                // -----------------------------------------------------------------------
                // -----------------------------------------------------------------------
                int r = fread(pc_buf_tmp, nNbOctPix, nNbCol, f);
                if (r != nNbCol)
                {
                    // -----------------------------------------------------------------------
                    SetError("MntIntersecteur::Charger()", "Echec lecture canal.");
                    return false;
                }
                // -----------------------------------------------------------------------
                pc_buf_tmp = pc_buf_tmp + nNbCol;
            }

            // -----------------------------------------------------------------------
            // recopie dans le buffer de doubles
            pc_buf_tmp = pc_buf;
            // -----------------------------------------------------------------------
            pZ = _pZ;
            // -----------------------------------------------------------------------
            for (nLig = 0; nLig < nNbLig; nLig++)
            {
                // -----------------------------------------------------------------------
                for (nCol = 0; nCol < nNbCol; nCol++)
                {
                    // -----------------------------------------------------------------------
                    *pZ = (double) (*pc_buf_tmp);
                    pZ++;
                    pc_buf_tmp++;
                }
            }
            free(pc_buf);
            break;
            // -----------------------------------------------------------------------
            //---------- unsigned char -------
        case eTVUChar:
            _TypeVal = eTVUChar;

            // -----------------------------------------------------------------------
            // allocation du buffer tampon
            // -----------------------------------------------------------------------
            unsigned char * puc_buf;
            unsigned char * puc_buf_tmp;
            // -----------------------------------------------------------------------
            puc_buf = (unsigned char *) malloc(_nc * _nl * sizeof(unsigned char));
            puc_buf_tmp = puc_buf;

            // -----------------------------------------------------------------------
            // Lecture d'un canal
            for (nLig = 0; nLig < nNbLig; nLig++)
            {
                // -----------------------------------------------------------------------
                int r = fread(puc_buf_tmp, nNbOctPix, nNbCol, f);
                // -----------------------------------------------------------------------
                if (r != nNbCol)
                {
                    SetError("MntIntersecteur::Charger()", "Echec lecture canal.");
                    return false;
                }
                // -----------------------------------------------------------------------
                puc_buf_tmp = puc_buf_tmp + nNbCol;
            }

            // -----------------------------------------------------------------------
            // recopie dans le buffer de doubles
            puc_buf_tmp = puc_buf;
            // -----------------------------------------------------------------------
            pZ = _pZ;
            // -----------------------------------------------------------------------
            for (nLig = 0; nLig < nNbLig; nLig++)
            {
                // -----------------------------------------------------------------------
                for (nCol = 0; nCol < nNbCol; nCol++)
                {
                    // -----------------------------------------------------------------------
                    *pZ = (double) (*puc_buf_tmp);
                    pZ++;
                    puc_buf_tmp++;
                }
            }
            free(puc_buf);
            break;
            // -----------------------------------------------------------------------
            //---------- short -------
        case eTVShort:
            _TypeVal = eTVShort;

            // -----------------------------------------------------------------------
            // allocation du buffer tampon
            short * ps_buf;
            // -----------------------------------------------------------------------
            short * ps_buf_tmp;
            // -----------------------------------------------------------------------
            ps_buf = (short *) malloc(_nc * _nl * sizeof(short));
            ps_buf_tmp = ps_buf;

            // -----------------------------------------------------------------------
            // Lecture d'un canal
            for (nLig = 0; nLig < nNbLig; nLig++)
            {
                // -----------------------------------------------------------------------
                int r = fread(ps_buf_tmp, nNbOctPix, nNbCol, f);
                if (r != nNbCol)
                // -----------------------------------------------------------------------
                {
                    // -----------------------------------------------------------------------
                    SetError("MntIntersecteur::Charger()", "Echec lecture canal.");
                    return false;
                }
                ps_buf_tmp = ps_buf_tmp + nNbCol;
            }

            // recopie dans le buffer de doubles
            ps_buf_tmp = ps_buf;
            pZ = _pZ;
            for (nLig = 0; nLig < nNbLig; nLig++)
            {
                for (nCol = 0; nCol < nNbCol; nCol++)
                {
                    *pZ = (double) (*ps_buf_tmp);
                    pZ++;
                    ps_buf_tmp++;
                }
            }
            // -----------------------------------------------------------------------
            free(ps_buf);
            break;
            // -----------------------------------------------------------------------
            //---------- unsigned short -------
            // -----------------------------------------------------------------------
        case eTVUShort:
            // -----------------------------------------------------------------------
            _TypeVal = eTVUShort;

            // -----------------------------------------------------------------------
            // allocation du buffer tampon
            unsigned short * pus_buf;
            // -----------------------------------------------------------------------
            unsigned short * pus_buf_tmp;
            // -----------------------------------------------------------------------
            pus_buf = (unsigned short *) malloc(_nc * _nl * sizeof(unsigned short));
            pus_buf_tmp = pus_buf;

            // -----------------------------------------------------------------------
            // Lecture d'un canal
            // -----------------------------------------------------------------------
            for (nLig = 0; nLig < nNbLig; nLig++)
            {
                // -----------------------------------------------------------------------
                int r = fread(pus_buf_tmp, nNbOctPix, nNbCol, f);
                if (r != nNbCol)
                {
                    // -----------------------------------------------------------------------
                    SetError("MntIntersecteur::Charger()", "Echec lecture canal.");
                    return false;
                }
                // -----------------------------------------------------------------------
                pus_buf_tmp = pus_buf_tmp + nNbCol;
            }

            // -----------------------------------------------------------------------
            // recopie dans le buffer de doubles
            pus_buf_tmp = pus_buf;
            // -----------------------------------------------------------------------
            pZ = _pZ;
            // -----------------------------------------------------------------------
            for (nLig = 0; nLig < nNbLig; nLig++)
            {
                // -----------------------------------------------------------------------
                for (nCol = 0; nCol < nNbCol; nCol++)
                {
                    *pZ = (double) (*pus_buf_tmp);
                    pZ++;
                    pus_buf_tmp++;
                }
            }
            // -----------------------------------------------------------------------
            free(pus_buf);
            break;
            // -----------------------------------------------------------------------
            //---------- int -------
        case eTVInt:
            // -----------------------------------------------------------------------
            _TypeVal = eTVInt;

            // -----------------------------------------------------------------------
            // allocation du buffer tampon
            int * pi_buf;
            // -----------------------------------------------------------------------
            int * pi_buf_tmp;
            // -----------------------------------------------------------------------
            pi_buf = (int *) malloc(_nc * _nl * sizeof(int));
            pi_buf_tmp = pi_buf;

            // -----------------------------------------------------------------------
            // Lecture d'un canal
            for (nLig = 0; nLig < nNbLig; nLig++)
            {
                // -----------------------------------------------------------------------
                int r = fread(pi_buf_tmp, nNbOctPix, nNbCol, f);
                // -----------------------------------------------------------------------
                if (r != nNbCol)
                {
                    // -----------------------------------------------------------------------
                    SetError("MntIntersecteur::Charger()", "Echec lecture canal.");
                    return false;
                }
                // -----------------------------------------------------------------------
                pi_buf_tmp = pi_buf_tmp + nNbCol;
            }

            // -----------------------------------------------------------------------
            // recopie dans le buffer de doubles
            // -----------------------------------------------------------------------
            pi_buf_tmp = pi_buf;
            // -----------------------------------------------------------------------
            pZ = _pZ;
            // -----------------------------------------------------------------------
            for (nLig = 0; nLig < nNbLig; nLig++)
            {
                // -----------------------------------------------------------------------
                for (nCol = 0; nCol < nNbCol; nCol++)
                {
                    // -----------------------------------------------------------------------
                    *pZ = (double) (*pi_buf_tmp);
                    pZ++;
                    pi_buf_tmp++;
                }
            }
            // -----------------------------------------------------------------------
            free(pi_buf);
            break;
            //---------- unsigned int -------
            // -----------------------------------------------------------------------
        case eTVUInt:
            // -----------------------------------------------------------------------
            _TypeVal = eTVUInt;

            // -----------------------------------------------------------------------
            // allocation du buffer tampon
            unsigned int * pui_buf;
            // -----------------------------------------------------------------------
            unsigned int * pui_buf_tmp;
            pui_buf = (unsigned int *) malloc(_nc * _nl * sizeof(unsigned int));
            // -----------------------------------------------------------------------
            pui_buf_tmp = pui_buf;

            // -----------------------------------------------------------------------
            // Lecture d'un canal
            for (nLig = 0; nLig < nNbLig; nLig++)
            {
                // -----------------------------------------------------------------------
                int r = fread(pui_buf_tmp, nNbOctPix, nNbCol, f);
                if (r != nNbCol)
                // -----------------------------------------------------------------------
                {
                    // -----------------------------------------------------------------------
                    SetError("MntIntersecteur::Charger()", "Echec lecture canal.");
                    return false;
                }
                // -----------------------------------------------------------------------
                pui_buf_tmp = pui_buf_tmp + nNbCol;
            }

            // -----------------------------------------------------------------------
            // recopie dans le buffer de doubles
            pui_buf_tmp = pui_buf;
            pZ = _pZ;
            // -----------------------------------------------------------------------
            for (nLig = 0; nLig < nNbLig; nLig++)
            // -----------------------------------------------------------------------
            {
                // -----------------------------------------------------------------------
                for (nCol = 0; nCol < nNbCol; nCol++)
                {
                    // -----------------------------------------------------------------------
                    *pZ = (double) (*pui_buf_tmp);
                    pZ++;
                    pui_buf_tmp++;
                }
            }
            // -----------------------------------------------------------------------
            free(pui_buf);
            break;
            // -----------------------------------------------------------------------
            //---------- float -------
        case eTVFloat:
            _TypeVal = eTVFloat;
            // -----------------------------------------------------------------------

            pZ = _pZ;
            // -----------------------------------------------------------------------
            for (nLig = 0; nLig < nNbLig; nLig++)
            {
                // -----------------------------------------------------------------------
                int r = fread(pZ, nNbOctPix, nNbCol, f);
                if (r != nNbCol)
                // -----------------------------------------------------------------------
                {
                    SetError("MntIntersecteur::Charger()", "Echec lecture canal.");
                    return false;
                }
                pZ = pZ + nNbCol;
            }
            break;
            // -----------------------------------------------------------------------
            //---------- double -------
        case eTVDouble:
            // -----------------------------------------------------------------------
            _TypeVal = eTVDouble;

            // -----------------------------------------------------------------------
            // allocation du buffer tampon
            double * pd_buf;
            // -----------------------------------------------------------------------
            double * pd_buf_tmp;
            pd_buf = (double *) malloc(_nc * _nl * sizeof(double));
            // -----------------------------------------------------------------------
            pd_buf_tmp = pd_buf;

            // -----------------------------------------------------------------------
            // Lecture d'un canal
            for (nLig = 0; nLig < nNbLig; nLig++)
            {
                // -----------------------------------------------------------------------
                int r = fread(pd_buf_tmp, nNbOctPix, nNbCol, f);
                if (r != nNbCol)
                {
                    // -----------------------------------------------------------------------
                    SetError("MntIntersecteur::Charger()", "Echec lecture canal.");
                    return false;
                }
                // -----------------------------------------------------------------------
                pd_buf_tmp = pd_buf_tmp + nNbCol;
            }

            // -----------------------------------------------------------------------
            // recopie dans le buffer de doubles
            pd_buf_tmp = pd_buf;
            // -----------------------------------------------------------------------
            pZ = _pZ;
            for (nLig = 0; nLig < nNbLig; nLig++)
            // -----------------------------------------------------------------------
            {
                for (nCol = 0; nCol < nNbCol; nCol++)
                // -----------------------------------------------------------------------
                {
                    *pZ = (double) (*pd_buf_tmp);
                    pZ++;
                    // -----------------------------------------------------------------------
                    pd_buf_tmp++;
                }
            }
            free(pd_buf);
            break;
            // -----------------------------------------------------------------------
        default:
            SetError("MntIntersecteur::Charger()", "TYPE_CODE introuvable");
            break;
            }
        // -----------------------------------------------------------------------

        // Fermeture de l'image
        fclose(f);
        // -----------------------------------------------------------------------

        // G?n?ration des altitudes inf et sup de chaque maille du MNT
        CalculerALtitudesMinMax();

        // -----------------------------------------------------------------------
        _bIsLoaded = true;
        return true;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////
    // Charger
    ////////////////////////////////////////////////////////////////////////////////////////////////
    bool
    MntIntersecteur::Charger(const double x0, // LON_REF
            const double y0, // LAT_REF
            const double px, // PAS_LON
            const double py, // PAS_LAT
            const int typeConv, const int nc, const int nl, double * z)
    {
        // -----------------------------------------------------------------------
        _x0 = x0;
        _y0 = y0;
        _nc = nc;
        _nl = nl;
        _px = px;
        _py = py;
        // -----------------------------------------------------------------------
        int nTypeConv = typeConv;
        _Ident = "";
        _pZ = z;
        // -----------------------------------------------------------------------
        _freepZ = false; // do NOT free _pZ. This action must be do by the user call code source.
        _TypeVal = eTVDouble;
        // -----------------------------------------------------------------------

        switch (nTypeConv)
            {
        // -----------------------------------------------------------------------
        case eTCNone:
            /*
             _typeConv = eTCNone;
             */
            break;
            // -----------------------------------------------------------------------
        case eTCRelative:
            /*
             _typeConv = eTCRelative;
             if ( !fmyread("H_REF", Temp) ) bErrorReadingHeader = true;
             _specConv._relat._altitudeRef = FromString<double>(Temp);
             if ( !fmyread("S_H", Temp) ) bErrorReadingHeader = true;
             _specConv._relat._scale = FromString<double>(Temp);
             */
            {
                SetError("MntIntersecteur::Charger()", "Seul le TypeConv 'None' est g?r?.");
                return false;
            }
            break;
            // -----------------------------------------------------------------------
        case eTCIntervale:
            /*
             _typeConv = eTCIntervale;
             if ( !fmyread("H_MIN", Temp) ) bErrorReadingHeader = true;
             _specConv._inter._altitudeMin = FromString<double>(Temp);
             if ( !fmyread("H_MAX", Temp) ) bErrorReadingHeader = true;
             _specConv._inter._altitudeMax = FromString<double>(Temp);
             */
            {
                SetError("MntIntersecteur::Charger()", "Seul le TypeConv 'None' est g?r?.");
                return false;
            }
            break;
        default:
            break;
            }

        // -----------------------------------------------------------------------
        // Respect de l'existant SP5LIB...
        if (_Ident == "GRS80_GEO")
        {
            // -----------------------------------------------------------------------
            _Ident = "GRS80:G-D/GRS80:Z-M";
        }

        // -----------------------------------------------------------------------
        _d1 = _px;
        _d2 = _py;

        // -----------------------------------------------------------------------
        _i1 = 1.0 / _py;
        _i2 = 1.0 / _px;

        // -----------------------------------------------------------------------
        // Contr?les
        if (_nc < 2 || _nl < 2)
        {
            SetError("MntIntersecteur::Charger()", "Dimensions de grille incorrectes.");
            return false;
        }

        // -----------------------------------------------------------------------
        // G?n?ration des altitudes inf et sup de chaque maille du MNT
        CalculerALtitudesMinMax();

        _bIsLoaded = true;
        return true;
    }

    void
    MntIntersecteur::CalculerALtitudesMinMax()
    {
        // -----------------------------------------------------------------------
        if (_pZMin)
            free(_pZMin);
        // -----------------------------------------------------------------------
        _pZMin = (double *) malloc((_nc - 1) * (_nl - 1) * sizeof(double));
        // -----------------------------------------------------------------------
        if (_pZMax)
            free(_pZMax);
        // -----------------------------------------------------------------------
        _pZMax = (double *) malloc((_nc - 1) * (_nl - 1) * sizeof(double));

        // -----------------------------------------------------------------------
        // On calcule les altitudes min et max du MNT

        // -----------------------------------------------------------------------
        int i, j, k, NC, NL;
        // -----------------------------------------------------------------------
        double nMin = 32000;
        double nMax = -32000;
        // -----------------------------------------------------------------------
        double *pZ1, *pZ2, *pZ3, *pZ4;

        // -----------------------------------------------------------------------
        // On rfait les choses proprement
        double f_altmin, f_altmax;
        double i_altmin, i_altmax;

        // -----------------------------------------------------------------------
        NC = _nc - 1;
        NL = _nl - 1;

        // -----------------------------------------------------------------------
        _zMin = nMin;
        _zMax = nMax;

        // -----------------------------------------------------------------------
        for (i = 0, k = 0; i < NL; i++)
        {
            // -----------------------------------------------------------------------
            for (j = 0; j < NC; j++, k++)
            {
                // -----------------------------------------------------------------------
                f_altmin = nMin;
                f_altmax = nMax;

                // -----------------------------------------------------------------------
                pZ1 = _pZ + (i * _nc + j);
                if (*pZ1 < f_altmin)
                    f_altmin = *pZ1;
                if (*pZ1 > f_altmax)
                    f_altmax = *pZ1;

                // -----------------------------------------------------------------------
                pZ2 = _pZ + (i * _nc + j + 1);
                if (*pZ2 < f_altmin)
                    f_altmin = *pZ2;
                if (*pZ2 > f_altmax)
                    f_altmax = *pZ2;

                // -----------------------------------------------------------------------
                pZ3 = _pZ + ((i + 1) * _nc + j);
                if (*pZ3 < f_altmin)
                    f_altmin = *pZ3;
                if (*pZ3 > f_altmax)
                    f_altmax = *pZ3;

                // -----------------------------------------------------------------------
                pZ4 = _pZ + ((i + 1) * _nc + j + 1);
                if (*pZ4 < f_altmin)
                    f_altmin = *pZ4;
                if (*pZ4 > f_altmax)
                    f_altmax = *pZ4;

                // -----------------------------------------------------------------------
                i_altmin = (double) floor(f_altmin);
                i_altmax = (double) ceil(f_altmax);
                _pZMin[k] = i_altmin;
                _pZMax[k] = i_altmax;
                // -----------------------------------------------------------------------

                if (i_altmin < _zMin)
                    _zMin = i_altmin;
                // -----------------------------------------------------------------------
                if (i_altmax > _zMax)
                    _zMax = i_altmax;
            }
        }
    }
    ////////////////////////////////////////////////////////////////////////////////////////////////
    // CheckCubeMnt
    ////////////////////////////////////////////////////////////////////////////////////////////////
    bool
    MntIntersecteur::CheckCubeMnt(const std::vector<std::vector<double> > & Visee, std::vector<double> & PointB, double & dH3D,
            bool & bTrouve)
    {
        // -----------------------------------------------------------------------
        std::vector < std::vector<double> > ViseeMNT;
        TersToMnts(Visee, ViseeMNT);

        // -----------------------------------------------------------------------
        short f(0), q(0), nbi(0);
        unsigned short p(0);
        double posA(0.), posB(0.); // Positions par rapport au plan (<0 : en dessous, =0 : sur le plan, >0 : au dessus)
        // -----------------------------------------------------------------------
        double a[6], b[6], c[6], d[6]; // Equation du plan a.u + b.v + c.z  = d
        // -----------------------------------------------------------------------
        double ui[6], vi[6], zi[6]; // Intersection de la visee avec les 6 plans
        double hi[6]; // Abscisse des intersections sur la visee
        std::vector<double> sA(3), sB(3);
        // -----------------------------------------------------------------------
        double cA(0.), cB(0.);
        // -----------------------------------------------------------------------
        bool estSurCube(false);
        double dtmp(0.);

        // -----------------------------------------------------------------------
        // Equations des plans correspondants aux 6 faces du cube MNT
        // Equation du plan a.u + b.v + c.z  = d
        a[0] = 1;
        b[0] = 0;
        c[0] = 0;
        d[0] = 0; // Plan u = 0
        // -----------------------------------------------------------------------
        a[1] = 1;
        b[1] = 0;
        c[1] = 0;
        d[1] = _nl - 1; // Plan u = nl - 1
        // -----------------------------------------------------------------------
        a[2] = 0;
        b[2] = 1;
        c[2] = 0;
        d[2] = 0; // Plan v = 0
        // -----------------------------------------------------------------------
        a[3] = 0;
        b[3] = 1;
        c[3] = 0;
        d[3] = _nc - 1; // Plan v = nc - 1
        // -----------------------------------------------------------------------
        a[4] = 0;
        b[4] = 0;
        c[4] = 1;
        d[4] = _zMin; // Plan z = hMin
        // -----------------------------------------------------------------------
        a[5] = 0;
        b[5] = 0;
        c[5] = 1;
        d[5] = _zMax; // Plan z = hMax

        // -----------------------------------------------------------------------
        // Nombre d'intersections valides trouvees
        nbi = 0;
        // -----------------------------------------------------------------------
        // On boucle sur les plans du cube MNT
        for (f = 0; f < 6; f++)
        {
            // -----------------------------------------------------------------------
            // Initialisation du sommet de la visee
            sB[0] = ViseeMNT[0][0];
            sB[1] = ViseeMNT[0][1];
            sB[2] = ViseeMNT[0][2];

            // -----------------------------------------------------------------------
            // Initialisation de la position par / au plan
            posB = a[f] * sB[0] + b[f] * sB[1] + c[f] * sB[2] - d[f];

            // -----------------------------------------------------------------------
            // On boucle sur les segments de la visee et on controle
            // si on traverse ou pas la face courante f du cube MNT
            for (p = 1; p < ViseeMNT.size(); p++)
            {
                // -----------------------------------------------------------------------
                // Transfert du point B dans le point A
                posA = posB;
                sA[0] = sB[0];
                sA[1] = sB[1];
                sA[2] = sB[2];

                // -----------------------------------------------------------------------
                // Reinit du point B
                sB[0] = ViseeMNT[p][0];
                sB[1] = ViseeMNT[p][1];
                sB[2] = ViseeMNT[p][2];

                // -----------------------------------------------------------------------
                // Initialisation de la position par / au plan
                posB = a[f] * sB[0] + b[f] * sB[1] + c[f] * sB[2] - d[f];

                // -----------------------------------------------------------------------
                // Test d'intersection
                if (posA * posB <= 0)
                {
                    // -----------------------------------------------------------------------
                    if (!posA && !posB)
                    {
                        // Trop de solutions !! (A et B sont sur le plan)
                        continue;
                    }
                    // -----------------------------------------------------------------------
                    else if (!posA)
                    {
                        // A est solution (il est sur le plan)
                        ui[nbi] = sA[0];
                        vi[nbi] = sA[1];
                        zi[nbi] = sA[2];
                        hi[nbi] = p - 1;
                    }
                    // -----------------------------------------------------------------------
                    else if (!posB)
                    {
                        // B est solution (il est sur le plan)
                        ui[nbi] = sB[0];
                        vi[nbi] = sB[1];
                        zi[nbi] = sB[2];
                        hi[nbi] = p;
                    }
                    // -----------------------------------------------------------------------
                    else
                    {
                        // -----------------------------------------------------------------------
                        // A et B sont de part et d'autre du plan
                        // Coefficients d'interpolation de l'intersection
                        // entre A et B
                        cA = posB / (posB - posA);
                        cB = -posA / (posB - posA);

                        // Affectation ou interpolation
                        // NB : pour ?viter les pb lors du test
                        //      <estSurCube> (voir + loin)
                        // . coordonn?e <u> (ligne)
                        // -----------------------------------------------------------------------
                        if (f < 2)
                        {
                            ui[nbi] = d[f];
                        }
                        // -----------------------------------------------------------------------
                        else
                        {
                            ui[nbi] = cA * sA[0] + cB * sB[0];
                        }
                        // -----------------------------------------------------------------------
                        // . coordonn?e <v> (colonne)
                        if (f > 1 && f < 4)
                        {
                            vi[nbi] = d[f];
                        }
                        else
                        {
                            vi[nbi] = cA * sA[1] + cB * sB[1];
                        }
                        // -----------------------------------------------------------------------
                        // . coordonn?e <z> (altitude)
                        if (f > 3)
                        {
                            zi[nbi] = d[f];
                        }
                        // -----------------------------------------------------------------------
                        else
                        {
                            zi[nbi] = cA * sA[2] + cB * sB[2];
                        }
                        // . coordonn?e <h> (abscisse vis?e)
                        hi[nbi] = p - cA;
                    }

                    // -----------------------------------------------------------------------
                    // Incrementation du nombre d'intersections trouvees
                    nbi++;

                    // -----------------------------------------------------------------------
                    // Passage a la face du cube suivante
                    break;
                }

            }

        }

        // -----------------------------------------------------------------------
        // Tri des points le long de la visee (il y en a au moins deux)
        for (p = 0; p < nbi - 1; p++)
        {
            for (q = p + 1; q < nbi; q++)
            {
                if (hi[q] < hi[p])
                {
                    dtmp = ui[p];
                    ui[p] = ui[q];
                    ui[q] = dtmp;
                    dtmp = vi[p];
                    vi[p] = vi[q];
                    vi[q] = dtmp;
                    dtmp = zi[p];
                    zi[p] = zi[q];
                    zi[q] = dtmp;
                    dtmp = hi[p];
                    hi[p] = hi[q];
                    hi[q] = dtmp;
                }
            }
        }

        // -----------------------------------------------------------------------
        // Filtrage des points non situes sur le cube
        for (p = 0; p < nbi;)
        {
            estSurCube = ui[p] >= d[0] && ui[p] <= d[1] && vi[p] >= d[2] && vi[p] <= d[3] && zi[p] >= d[4] && zi[p] <= d[5];
            if (!estSurCube)
            {
                // On translate tous les points suivants (on ecrase ce point non valide)
                for (q = p + 1; q < nbi; q++)
                {
                    ui[q - 1] = ui[q];
                    vi[q - 1] = vi[q];
                    zi[q - 1] = zi[q];
                    hi[q - 1] = hi[q];
                }
                nbi--;
            }
            else
            {
                p++;
            }
        }

        // -----------------------------------------------------------------------
        // Pas de solution si 0 ou 1 seul point trouve (on a tangente le cube)
        if (nbi < 2)
        {
            bTrouve = false;
            return true;
        }

        // -----------------------------------------------------------------------
        // Il ne reste que 2 points donc on traverse le cube
        // LAIG-FA-MAJA-2168-CNES: plus de filtrage sur les point identiques. Il peut y avoir un nombre depoints > 2
        // Initialisation du point courant
        // Coordonnees MNT
        std::vector<double> PointMnt(3);
        PointMnt[0] = ui[0];
        PointMnt[1] = vi[0];
        PointMnt[2] = zi[0];

        // -----------------------------------------------------------------------
        // h dans gld 3D
        dH3D = hi[0];

        // -----------------------------------------------------------------------
        // Coordonnees terrain
        MntToTer(PointMnt, PointB);

        // -----------------------------------------------------------------------
        // Fin, retour
        bTrouve = true;
        return true;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////
    // Intersection
    ////////////////////////////////////////////////////////////////////////////////////////////////
    bool
    MntIntersecteur::Intersection(const std::vector<std::vector<double> > & Visee, const std::vector<double> & H3D,
            std::vector<double> & PointB, double & dH3D, std::vector<double> & PointR, bool & bTrouve)
    {
        PointR.resize(3);

        std::vector < std::vector<double> > ViseeMNT;
        TersToMnts(Visee, ViseeMNT);
        std::vector<double> PointB_MNT;
        TerToMnt(PointB, PointB_MNT);

        double h1, d1, h2, d2; // Altitudes et ecarts d'altitude
        double u0, v0, z0, z1; // Point duquel est issue la visee (et altitude "suivante")
        long nu, nv; // Taille MNT
        double a2; // a1, Abscisses relative d'un point entre 2 sommet de la visee (= coef d'interpolation)
        unsigned long i0; // Indice du sommet dans la direction de visee
        long uc, vc; // Indice entier de la maille MNT courante
        // Point haut et point bas
        std::vector<double> p1(3);
        std::vector<double> p2(3);

        p1[0] = PointB_MNT[0];
        p1[1] = PointB_MNT[1];
        p1[2] = PointB_MNT[2];
        double dH3D_p1 = dH3D;

        double zv; // z vrai
        double ua, va, za;

        double ch, hi, hs; // Coef d'interpolation de h entre hinf et hsup

        nu = _nl;
        nv = _nc;

        // 1 - Initilialisation et tests prealables
        // 1.1 - Test si le sommet est au-dessu du MNT
        //    - Calcul de l'altitude du MNT ? la position du sommet
        h1 = MakeAlti(p1[0], p1[1]);

        //    - Calcul de l'?cart d'altitude au MNT
        d1 = p1[2] - h1;

        //    - Test si le nouveau point haut est au dessus du MNT
        if (d1 < 0)
        {
            // - Point situ? en dessous du MNT
            //   . ceci signifie que la vis?e rentre dans le MNT par le c?t?
            //   . donc en dessous, pas de solution
            bTrouve = false;
            return true;
        }

        // 1.2 - Initialisation du rang du premier sommet de la visee
        i0 = (long) floor(dH3D_p1);

        // 1.3 - Initialisation du point de depart (dans p2)
        p2[0] = PointB_MNT[0];
        p2[1] = PointB_MNT[1];
        p2[2] = PointB_MNT[2];
        double dH3D_p2 = dH3D;

        std::vector<double> VM(3);

        // 2. - Boucle sur les plans de grille
        while (i0 < ViseeMNT.size() - 1)
        {
            // 2.1 - Initialisation du sommet courant de la visee
            u0 = ViseeMNT[i0][0];
            v0 = ViseeMNT[i0][1];
            z0 = ViseeMNT[i0][2];
            z1 = ViseeMNT[i0 + 1][2];

            // 2.2 - Initialisation de la visee MNT
            VM[0] = ViseeMNT[i0 + 1][0] - ViseeMNT[i0][0];
            VM[1] = ViseeMNT[i0 + 1][1] - ViseeMNT[i0][1];
            VM[2] = ViseeMNT[i0 + 1][2] - ViseeMNT[i0][2];

            // 2.3 - Test si visee verticale
            if (!VM[0] && !VM[1])
            {
                // 2.3.1 - La vis?e est verticale :
                //    - Calcul de l'altitude du MNT ? la position du sommet
                h1 = MakeAlti(u0, v0);

                // Test si le plan suivant est en dessous du MNT
                if (ViseeMNT[i0 + 1][2] <= h1)
                {
                    // Init point de sortie
                    p1[0] = u0;
                    p1[1] = v0;
                    p1[2] = h1;
                    bTrouve = true;
                    MntToTer(p1, PointR);
                    return true;
                }
                else
                {
                    // Positionnement sur le sommet suivant
                    i0++;
                }
            }
            else
            {
                // 2.3.2 - La vis?e n'est pas verticale :
                //         elle va donc survoler le MNT
                //         . on peut donc poursuivre
                //         . reste ? d?montrer que la vis?e se crashe sur le MNT...

                // Initialisation du point de d?part
                // Initialisation de son abscisse sur la vis?e
                a2 = dH3D_p2 - i0;

                // Correction d'un bug FA DG 10, a la reinitialisation a2 peut valoir 1
                // Ce qui a pour consequence de sauter au segment suivant de la visee
                // Ainsi, on peut perdre des points sur une tranche d'altitude
                // Pour etre sur de scanner le segment de visee, on reinitialise
                // le point au depart du segment, soit a2 = 0
                if (a2 >= 1.)
                    a2 = 0.;

                // Initialisation de la premi?re maille MNT intersect?e
                //  - Initialisation des indices de la maille
                uc = (int) floor(p2[0]);
                vc = (int) floor(p2[1]);

                // NB :    pr?caution avant de d?marrer :
                //       . on se met du bon c?t? de la maille
                //       . en principe, on ne doit pas sortir du MNT
                // On rentre par le bas, la maille MNT est la precedente
                if (p2[0] == uc && VM[0] < 0)
                {
                    uc--;
                }

                // On rentre par la gauche, la maille MNT est la precedente
                if (p2[1] == vc && VM[1] < 0)
                {
                    vc--;
                }

                // LDD - On est d?j? en dehors des limites, on s'arrete
                if ((!(a2 < 1 && uc > -1 && uc < (nu - 1) && vc > -1 && vc < (nv - 1))) && (a2 < 1))
                {
                    bTrouve = false;
                    return true;
                }

                // Boucle de recherche it?rative de la maille intersect?e
                while (a2 < 1 && uc > -1 && uc < (nu - 1) && vc > -1 && vc < (nv - 1))
                {
                    // - Altitudes min et max de la maille
                    hi = _pZMin[uc * (nv - 1) + vc];
                    hs = _pZMax[uc * (nv - 1) + vc];

                    // - Transfert : le point bas devient le point haut
                    //a1 = a2;
                    // p1 devient p2
                    p1[0] = p2[0];
                    p1[1] = p2[1];
                    p1[2] = p2[2];
                    dH3D_p1 = dH3D_p2;

                    // 4.2 - D?termination d'un nouveau point bas
                    //     - Test d'orientation de la vis?e
                    if (!VM[0])
                    {
                        // 4.2.1 - La vis?e est orientee pile poil est-ouest
                        //   p2[0] = p1[0] ; // inutile, est deja initialise
                        //       - Test d'orientation de la vis?e
                        if (VM[1] < 0)
                        {
                            // 4.2.1.1 - La vis?e part plein ouest
                            p2[1] = vc;
                            vc--;
                        }
                        else
                        {
                            // 4.2.1.2 - La vis?e part plein est
                            vc++;
                            p2[1] = vc;
                        }
                        a2 = (p2[1] - v0) / VM[1];
                        p2[2] = z0 + a2 * VM[2];
                    }
                    else if (!VM[1])
                    {
                        // 4.2.2 - La vis?e est orient?e nord-sud
                        //  p2[1] = p1[1] ;
                        //       - Test d'orientation de la vis?e
                        if (VM[0] < 0)
                        {
                            // 4.2.2.1 - La vis?e part plein nord
                            p2[0] = uc;
                            uc--;
                        }
                        else
                        {
                            // 4.2.2.2 - La vis?e part plein sud
                            uc++;
                            p2[0] = uc;
                        }
                        a2 = (p2[0] - u0) / VM[0];
                        p2[2] = z0 + a2 * VM[2];
                    }
                    else
                    {
                        // 4.2.3 - La vis?e est quelconque
                        //           - D?termination du cot? de sortie
                        if (VM[0] < 0 && VM[0] <= VM[1] && VM[0] <= -VM[1])
                        {
                            // 4.2.3.1 - Vis?e principalement orient?e nord
                            //             - Intersection avec le c?t? nord
                            a2 = (uc - u0) / VM[0];
                            p2[1] = v0 + a2 * VM[1];
                            if (p2[1] > vc && p2[1] < vc + 1)
                            {
                                // La vis?e sort par le nord
                                p2[0] = uc;
                                p2[2] = z0 + a2 * VM[2];
                                uc--;
                            }
                            else if (p2[1] < vc)
                            {
                                // La vis?e sort par l'ouest
                                a2 = (vc - v0) / VM[1];
                                p2[0] = u0 + a2 * VM[0];
                                p2[1] = vc;
                                p2[2] = z0 + a2 * VM[2];
                                vc--;
                            }
                            else if (p2[1] > vc + 1)
                            {
                                // La vis?e sort par l'est
                                vc++;
                                a2 = (vc - v0) / VM[1];
                                p2[0] = u0 + a2 * VM[0];
                                p2[1] = vc;
                                p2[2] = z0 + a2 * VM[2];
                            }
                            else if (p2[1] == vc)
                            {
                                // La vis?e sort par le coin nord-ouest
                                p2[0] = uc;
                                p2[1] = vc;
                                p2[2] = z0 + a2 * VM[2];
                                uc--;
                                vc--;
                            }
                            else if (p2[1] == vc + 1)
                            {
                                // La vis?e sort par le coin nord-est
                                p2[0] = uc;
                                vc++;
                                p2[1] = vc;
                                p2[2] = z0 + a2 * VM[2];
                                uc--;
                            }
                        }
                        else if (VM[1] > 0 && VM[1] >= VM[0] && VM[1] >= -VM[0])
                        {
                            // 4.2.3.2 - Vis?e principalement orient?e est
                            //         - Intersection avec le c?t? est
                            a2 = (vc + 1 - v0) / VM[1];
                            p2[0] = u0 + a2 * VM[0];
                            if (p2[0] > uc && p2[0] < uc + 1)
                            {
                                // La vis?e sort par l'est
                                vc++;
                                p2[1] = vc;
                                p2[2] = z0 + a2 * VM[2];
                            }
                            else if (p2[0] < uc)
                            {
                                // La vis?e sort par le nord
                                p2[0] = uc;
                                a2 = (uc - u0) / VM[0];
                                p2[1] = v0 + a2 * VM[1];
                                p2[2] = z0 + a2 * VM[2];
                                uc--;
                            }
                            else if (p2[0] > uc + 1)
                            {
                                // La vis?e sort par le sud
                                uc++;
                                p2[0] = uc;
                                a2 = (uc - u0) / VM[0];
                                p2[1] = v0 + a2 * VM[1];
                                p2[2] = z0 + a2 * VM[2];
                            }
                            else if (p2[0] == uc)
                            {
                                // La vis?e sort par le coin nord-est
                                vc++;
                                p2[0] = uc;
                                p2[1] = vc;
                                p2[2] = z0 + a2 * VM[2];
                                uc--;
                            }
                            else if (p2[0] == uc + 1)
                            {
                                // La vis?e sort par le coin sud-est
                                uc++;
                                vc++;
                                p2[0] = uc;
                                p2[1] = vc;
                                p2[2] = z0 + a2 * VM[2];
                            }
                        }
                        else if (VM[0] > 0 && VM[0] >= VM[1] && VM[0] >= -VM[1])
                        {
                            // 4.2.3.3 - Vis?e principalement orient?e sud
                            //         - Intersection avec le c?t? sud
                            a2 = (uc + 1 - u0) / VM[0];
                            p2[1] = v0 + a2 * VM[1];
                            if (p2[1] > vc && p2[1] < vc + 1)
                            {
                                // La vis?e sort par le sud
                                uc++;
                                p2[0] = uc;
                                p2[2] = z0 + a2 * VM[2];
                            }
                            else if (p2[1] < vc)
                            {
                                // La vis?e sort par l'ouest
                                a2 = (vc - v0) / VM[1];
                                p2[0] = u0 + a2 * VM[0];
                                p2[1] = vc;
                                p2[2] = z0 + a2 * VM[2];
                                vc--;
                            }
                            else if (p2[1] > vc + 1)
                            {
                                // La vis?e sort par l'est
                                vc++;
                                a2 = (vc - v0) / VM[1];
                                p2[0] = u0 + a2 * VM[0];
                                p2[1] = vc;
                                p2[2] = z0 + a2 * VM[2];
                            }
                            else if (p2[1] == vc)
                            {
                                // La vis?e sort par le coin sud-ouest
                                uc++;
                                p2[0] = uc;
                                p2[1] = vc;
                                p2[2] = z0 + a2 * VM[2];
                                vc--;
                            }
                            else if (p2[1] == vc + 1)
                            {
                                // La vis?e sort par le coin sud-est
                                uc++;
                                vc++;
                                p2[0] = uc;
                                p2[1] = vc;
                                p2[2] = z0 + a2 * VM[2];
                            }
                        }
                        else if (VM[1] < 0 && VM[1] <= VM[0] && VM[1] <= -VM[0])
                        {
                            // 4.2.3.4 - Vis?e principalement orient?e ouest
                            //         - Intersection avec le c?t? ouest
                            a2 = (vc - v0) / VM[1];
                            p2[0] = u0 + a2 * VM[0];
                            if (p2[0] > uc && p2[0] < uc + 1)
                            {
                                // La vis?e sort par l'ouest
                                p2[1] = vc;
                                p2[2] = z0 + a2 * VM[2];
                                vc--;
                            }
                            else if (p2[0] < uc)
                            {
                                // La vis?e sort par le nord
                                p2[0] = uc;
                                a2 = (uc - u0) / VM[0];
                                p2[1] = v0 + a2 * VM[1];
                                p2[2] = z0 + a2 * VM[2];
                                uc--;
                            }
                            else if (p2[0] > uc + 1)
                            {
                                // La vis?e sort par le sud
                                uc++;
                                p2[0] = uc;
                                a2 = (uc - u0) / VM[0];
                                p2[1] = v0 + a2 * VM[1];
                                p2[2] = z0 + a2 * VM[2];
                            }
                            else if (p2[0] == uc)
                            {
                                // La vis?e sort par le coin nord-ouest
                                p2[0] = uc;
                                p2[1] = vc;
                                p2[2] = z0 + a2 * VM[2];
                                uc--;
                                vc--;
                            }
                            else if (p2[0] == uc + 1)
                            {
                                // La vis?e sort par le coin sud-ouest
                                uc++;
                                p2[0] = uc;
                                p2[1] = vc;
                                p2[2] = z0 + a2 * VM[2];
                                vc--;
                            }
                        }
                    }

                    /// LDD - Verification des bornes min et max de la "couche"
                    bool bIntersect = false;
                    if (p2[2] > z0) // On est remont? trop haut, et ca c'est pas bon !!!
                    {
                        bIntersect = !((p1[2] > hs && z0 > hs) || (p1[2] < hi && z0 < hi));
                    }
                    else if (p2[2] < z1) // On est descendu trop bas, et ca c'est pas bon non plus !!! (m?me si c'est d?j? plus logique)
                    {
                        bIntersect = !((p1[2] > hs && z1 > hs) || (p1[2] < hi && z1 < hi));
                    }
                    else
                    {
                        bIntersect = !((p1[2] > hs && p2[2] > hs) || (p1[2] < hi && p2[2] < hi));
                    }

                    // 5. Test d'intersection de la vis?e avec le cube
                    if (bIntersect)
                    {
                        // Il y a intersection entre la vis?e et le cube
                        // 5.1 - Altitudes du MNT
                        h1 = MakeAlti(p1[0], p1[1]);
                        h2 = MakeAlti(p2[0], p2[1]);

                        // 5.2 - Diff?rences d'altitude avec le MNT
                        d1 = p1[2] - h1;
                        d2 = p2[2] - h2;

                        // 5.3 - Test d'intersection avec le MNT
                        // Check distance if = 0, no interpolation
                        if (fabs(d1) < TOL_D)
                        {
                            bTrouve = true;
                            MntToTer(p1, PointR);
                            return true;
                        }
                        else if (fabs(d2) < TOL_D)
                        {
                            bTrouve = true;
                            MntToTer(p2, PointR);
                            return true;
                        }
                        else if (d1 * d2 <= 0)
                        {
                            // Il y a intersection entre la vis?e et le MNT
                            // 5.3.1 - Calcul de la solution approch?e
                            d2 = 2 * TOL_Z; // Init de d2 > TOL_Z
                            ua = p2[0];
                            va = p2[1];
                            za = h2;
                            while (fabs(d2) > TOL_Z)
                            {
                                // 5.3.1.1 - Coefficient d'interpolation lin?aire de h
                                ch = (p1[2] - h1) / ((h2 - h1) - (p2[2] - p1[2]));

                                // 5.3.1.2 - Position du point interpol?
                                ua = p1[0] + ch * (p2[0] - p1[0]);
                                va = p1[1] + ch * (p2[1] - p1[1]);
                                za = p1[2] + ch * (p2[2] - p1[2]);

                                // 5.3.1.3 - Altitude du point interpol?
                                zv = MakeAlti(ua, va);

                                // 5.3.1.4 - Ecart d'altitude au point interpol?
                                d2 = zv - za;

                                // 5.3.1.5 - Mise ? jour
                                if (d2 < 0)
                                {
                                    // Mise ? jour du point haut
                                    p1[0] = ua;
                                    p1[1] = va;
                                    p1[2] = za;
                                    h1 = zv;
                                }
                                else
                                {
                                    // Mise ? jour du point bas
                                    p2[0] = ua;
                                    p2[1] = va;
                                    p2[2] = za;
                                    h2 = zv;
                                }
                            }

                            // Fin, retour
                            p1[0] = ua;
                            p1[1] = va;
                            p1[2] = za;
                            bTrouve = true;
                            MntToTer(p1, PointR);
                            return true;
                        }
                    }

                } // Fin boucle sur les mailles

                // Test si on est toujours dans le cube MNT
                if (a2 >= 1)
                {
                    // Changement de plan
                    i0++;

                    // Chargement dans p2 du nouveau sommet
                    p2[0] = ViseeMNT[i0][0];
                    p2[1] = ViseeMNT[i0][1];
                    p2[2] = ViseeMNT[i0][2];
                    dH3D_p2 = H3D[i0];
                }
                else
                {
                    // LDD - On a boucl? sur les mailles, on n'a rien trouv? et on n'a pas atteint le plan suivant
                    // Ca veut dire qu'on sort de l'emprise, pas la peine de continuer
                    bTrouve = false;
                    return true;
                }

            } // Fin cas general (visee non verticale)

        } // Fin boucle sur les sommets

        // Fin, retour
        bTrouve = false;
        return true;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////
    // TersToMnts
    ////////////////////////////////////////////////////////////////////////////////////////////////
    void
    MntIntersecteur::TersToMnts(const std::vector<std::vector<double> > & Ters, std::vector<std::vector<double> > & Mnts)
    {
        Mnts.resize(Ters.size());

        unsigned int i;
        for (i = 0; i < Ters.size(); i++)
        {
            TerToMnt(Ters[i], Mnts[i]);
        }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////
    // MntsToTers
    ////////////////////////////////////////////////////////////////////////////////////////////////
    void
    MntIntersecteur::MntsToTers(const std::vector<std::vector<double> > & Mnts, std::vector<std::vector<double> > & Ters)
    {
        Ters.resize(Mnts.size());

        unsigned int i;
        for (i = 0; i < Mnts.size(); i++)
        {
            MntToTer(Mnts[i], Ters[i]);
        }
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////
    // TerToMnt
    ////////////////////////////////////////////////////////////////////////////////////////////////
    void
    MntIntersecteur::TerToMnt(const std::vector<double> & Ter, std::vector<double> & Mnt)
    {
        Mnt.resize(3);

        double dx, dy;

        dx = Ter[0] - _x0;
        dy = Ter[1] - _y0;

        Mnt[0] = _i1 * dy;
        Mnt[1] = _i2 * dx;

        Mnt[2] = Ter[2];
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////
    // MntToTer
    ////////////////////////////////////////////////////////////////////////////////////////////////
    void
    MntIntersecteur::MntToTer(const std::vector<double> & Mnt, std::vector<double> & Ter)
    {
        Ter.resize(3);

        double dx, dy;

        dx = _d1 * Mnt[1];
        dy = _d2 * Mnt[0];

        Ter[0] = _x0 + dx;
        Ter[1] = _y0 + dy;

        Ter[2] = Mnt[2];
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////
    // MakeAlti
    ////////////////////////////////////////////////////////////////////////////////////////////////
    double
    MntIntersecteur::MakeAlti(double dX, double dY)
    {
        // Indices des noeuds de la maille incluant le point
        // Remarque : Si le point est en fin de MNT, on prend l'avant dernier point du MNT comme r?f?rence
        //            pour pouvoir calculer son altitude avec des coefficients d'interpolation (1,1)
        //            plutot que de segmentation faulter avec des coefficients d'interpolation (0,0)
        int i1 = (dX >= _nl - 1) ? _nl - 2 : (int) floor(dX);
        int i2 = i1 + 1;
        int j1 = (dY >= _nc - 1) ? _nc - 2 : (int) floor(dY);
        int j2 = j1 + 1;
        // Coefficients d'interpolation bilin?aire
        double u = dY - j1;
        double v = dX - i1;
        // Altitude
        return (1 - u) * (1 - v) * _pZ[i1 * _nc + j1] + u * (1 - v) * _pZ[i1 * _nc + j2] + (1 - u) * v * _pZ[i2 * _nc + j1]
                + u * v * _pZ[i2 * _nc + j2];
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////
    // Intersection3D
    ////////////////////////////////////////////////////////////////////////////////////////////////
    bool
    MntIntersecteur::Intersection3D(const std::vector<double> & Point, const std::vector<double> & Visee, std::vector<double> & PointR,
            bool & bValid)
    {
        // -----------------------------------------------------------------------
        // V?rifications
        if (!GetIsLoaded())
        {
            SetError("MntIntersecteur::Intersection3D()", "Le MNT n'est pas charg?.");
            return false;
        }

        // -----------------------------------------------------------------------
        if (Point.size() != 3)
        {
            SetError("MntIntersecteur::Intersection3D()", "Le point doit contenir trois coordonnees (x,y,z).");
            return false;
        }

        // -----------------------------------------------------------------------
        if (Visee.size() != 3)
        {
            SetError("MntIntersecteur::Intersection3D()", "La visee doit contenir trois coordonnees (x,y,z).");
            return false;
        }

        // -----------------------------------------------------------------------
        if (Visee[2] >= 0)
        {
            SetError("MntIntersecteur::Intersection3D()", "La visee doit etre descendante.");
            return false;
        }

        // -----------------------------------------------------------------------
        // Constitution de la vis?e en 3D
        std::vector < std::vector<double> > Visee3D(2);
        std::vector<double> H3D(2);

        Visee3D[0] = Point;
        Visee3D[1].resize(3);
        Visee3D[1][0] = Point[0] + Visee[0];
        Visee3D[1][1] = Point[1] + Visee[1];
        Visee3D[1][2] = Point[2] + Visee[2];

        H3D[0] = 1;
        H3D[1] = 0;

        // -----------------------------------------------------------------------
        // Visee normalis?e en Z
        std::vector<double> ViseeN(3);
        ViseeN[0] = Visee[0] / Visee[2];
        ViseeN[1] = Visee[1] / Visee[2];
        ViseeN[2] = Visee[2] / Visee[2];

        // -----------------------------------------------------------------------
        // Extrapolation si necessaire
        double dMin = _zMin - 1;
        double dMax = _zMax + 1;

        // -----------------------------------------------------------------------
        if (Visee3D[0][2] < dMax)
        {
            double scale = (dMax - Visee3D[0][2]);
            Visee3D[0][0] += scale * ViseeN[0];
            Visee3D[0][1] += scale * ViseeN[1];
            Visee3D[0][2] += scale * ViseeN[2];
        }

        // -----------------------------------------------------------------------
        if (Visee3D[1][2] > dMin)
        {
            double scale = (dMin - Visee3D[1][2]);
            Visee3D[1][0] += scale * ViseeN[0];
            Visee3D[1][1] += scale * ViseeN[1];
            Visee3D[1][2] += scale * ViseeN[2];
        }

        // -----------------------------------------------------------------------
        // Intersection de la visee avec le cube MNT
        double dH3D;
        bool bTrouve;
        std::vector<double> PointB;
        if (!CheckCubeMnt(Visee3D, PointB, dH3D, bTrouve))
        {
            SetError("Intersecteur::Intersecter()", "Erreur lors de l'intersection avec la boite englobante.");
            return false;
        }

        // -----------------------------------------------------------------------
        if (!bTrouve)
        {
            bValid = false;
            return true;
        }

        // -----------------------------------------------------------------------
        // Intersection de la visee avec les mailles du MNT
        if (!Intersection(Visee3D, H3D, PointB, dH3D, PointR, bTrouve))
        {
            SetError("Intersecteur::Intersecter()", "Erreur lors de l'intersection avec le MNT.");
            return false;
        }

        // -----------------------------------------------------------------------
        bValid = bTrouve;
        return true;
    }

    void
    MntIntersecteur::Print(std::ostream & s)
    {
        // -----------------------------------------------------------------------
        s << "MntIntersecteur:Parameters" << std::endl;
        s << " _x0: " << _x0 << std::endl;
        s << " _y0: " << _y0 << std::endl;
        // -----------------------------------------------------------------------
        s << " _px: " << _px << std::endl;
        s << " _py: " << _py << std::endl;
        // -----------------------------------------------------------------------
        s << " _nl: " << _nl << std::endl;
        s << " _nc: " << _nc << std::endl;
        // -----------------------------------------------------------------------
        s << " _i1: " << _i1 << std::endl;
        s << " _i2: " << _i2 << std::endl;
        // -----------------------------------------------------------------------
        s << " _d1: " << _d1 << std::endl;
        s << " _d2: " << _d2 << std::endl;
        // -----------------------------------------------------------------------
        s << " _zMin: " << _zMin << std::endl;
        s << " _zMax: " << _zMax << std::endl;

    }
}
